---
title: "chapter 3 - Functional Principal Components Analysis"
author: "Vanilton Paulo"
date: "2025-08-16"
output:
  html_document: default
---

```{r setup, echo = TRUE, message = FALSE}
# ─Packages───────────────────
# List of required packages
packages <- c(
  "refund",
  "tidyverse",
  "tidyfun",
  "patchwork",
  "here"
)

# Install missing packages
install_if_missing <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

# Install missing packages
invisible(lapply(packages, install_if_missing))



#Calling all the packages 
library(refund)      
library(tidyverse)   
library(tidyfun)
library(patchwork)
library(here)



#For reproducible results
set.seed(53615)
```


```{r , include = TRUE}
# ─── Load data  ───────────────────
df_subj <- read_rds(here("data", "nhanes_fda_with_r.rds"))
```


```{r , include = TRUE, fig.width = 9}
# ─── Data Preparation ───────────────────
## filter out participants 80+ and younger than 5
df_subj <- df_subj %>% filter(age >= 5, age < 80)
MIMS_mat <- unclass(df_subj$MIMS) 
```

```{r , include = FALSE, fig.width = 9}
# ─── fpca.face ───────────────────
# Do fPCA on the subject-average MIMS profiles
fpca_MIMS_subj <- fpca.face(MIMS_mat)
fpc_face <- tfd(t(fpca_MIMS_subj$efunctions[, 1:4]), arg = 1:1440)

tf_integrate(fpc_face^2)
#[1] 0.9999874 0.9989462 0.9988505 0.9992566

fpca_face_tf <- fpc_face %>%
  set_names(paste0("PC", 1:4))
# tfd[4] on (1,1440) based on 1440 evaluations each
# interpolation by tf_approx_linear 
# PC1: (1,-0.004);(2,-0.004);(3,-0.004); ...
# PC2: (1,  0.03);(2,  0.03);(3,  0.03); ...
# PC3: (1,  0.03);(2,  0.03);(3,  0.03); ...
# PC4: (1,  0.03);(2,  0.03);(3,  0.03); ...
```


```{r , include = FALSE, fig.width = 9}
# ─── fpca2s ───────────────────
argvals <- seq(0, 1, length.out = ncol(MIMS_mat))
fpca2s_obj <- fpca2s(Y = MIMS_mat, npc = 4, argvals = argvals)
fpc_2s <- tfd(t(fpca2s_obj$efunctions[, 1:4]), arg = seq(1, 1440))

tf_integrate(fpc_2s^2)
#[1] 1438.940 1437.387 1436.987 1437.529

fpca2s_tf <- fpc_2s %>%
  set_names(paste0("PC", 1:4))
# tfd[4] on (1,1440) based on 1440 evaluations each
# interpolation by tf_approx_linear 
# PC1: (1,0.1);(2,0.1);(3,0.1); ...
# PC2: (1, -1);(2, -1);(3, -1); ...
# PC3: (1,  1);(2,  1);(3,  1); ...
# PC4: (1, -1);(2, -1);(3, -1); ...
```



```{r , include = FALSE, fig.width = 9}
# ─── tfb_fpc ───────────────────
tfb_fpc_obj <- tfb_fpc(MIMS_mat)  # default is SVD-based + spline smoothing
basis_functions <- tf_basis(tfb_fpc_obj, as_tfd = TRUE)
# skip the mean (first function), extract PC1 to PC4
fpc_tf <- basis_functions[2:5]
tf_integrate(fpc_tf^2)
#[1] 1 1 1 1


tfb_tf <- -fpc_tf %>%
  set_names(paste0("PC", 1:4))  
# tfd[4] on (1,1440) based on 1440 evaluations each
# interpolation by tf_approx_linear 
# PC1: (1,-0.004);(2,-0.004);(3,-0.004); ...
# PC2: (1, -0.03);(2, -0.03);(3, -0.03); ...
# PC3: (1,  0.03);(2,  0.03);(3,  0.03); ...
# PC4: (1,  0.03);(2,  0.03);(3,  0.03); ...
```


```{r , include = TRUE, fig.width = 25, fig.height = 9}
# ─── Common plot bits ─────────────
time_breaks <- c(1, 6 * 60, 12 * 60, 18 * 60, 23 * 60)
time_labels <- c("01:00", "06:00", "12:00", "18:00", "23:00")

make_pc_plot <- function(dat, title_txt) {
  ggplot(dat, aes(y = curve, color = Component)) +
    geom_spaghetti(alpha = 2) +   # one line per tf curve (PC) 
    scale_x_continuous(breaks = time_breaks, labels = time_labels, expand = c(0, 0)) +
    labs(
      title = title_txt,
      x = "Time of Day (s)",
      y = expression("Estimated Eigenfunctions (" * phi[k](s) * ")"),
      color = "Eigenfunction"
    ) +
    theme_minimal(base_size = 18) +
    theme(
      panel.grid      = element_blank(),
      axis.line       = element_line(linewidth = 1),
      axis.ticks      = element_line(linewidth = 1),
      plot.title      = element_text(face = "bold", size = 18, hjust = 0),
      legend.position.inside = c(0.9, 0.9),
      legend.background = element_blank()
    ) +
    guides(color = guide_legend(ncol = 2))
}

# ─── Build data frames per method ─
df_face   <- tibble(Component = names(fpca_face_tf), curve = fpca_face_tf)
df_fpca2s <- tibble(Component = names(fpca2s_tf),    curve = fpca2s_tf)
df_tfb    <- tibble(Component = names(tfb_tf),       curve = tfb_tf)

# ─── Three individual plots ───────
p_face   <- make_pc_plot(df_face,   "(A) fPCA (face)")
p_fpca2s <- make_pc_plot(df_fpca2s, "(B) fPCA (fpca2s)")
p_tfb    <- make_pc_plot(df_tfb,    "(C) fPCA (tfb_fpc)")

# Print individually (e.g., in the console or knit document)
p_face +p_tfb +p_fpca2s
```



```{r , include = TRUE, fig.width = 9}
#─────────────────────────── Goal ──────────────────────────────────────────────────────
#Interpreting the functional PCs may be challenging, particularly for PCs which explain a relatively 
#low proportion of variance. One visualization technique is to plot the distribution of curves which 
#load lowest/highest on a particular PC. 

#Task:Here, we plot the individuals in the bottom and top 10% of scores for the first four PCs. 


set.seed(1983)
# number of eigenfunctions to plot
K <- 4
# number of sample curves to plot for each PC
n_plt <- 10
sind  <- seq(0, 1, length.out = 1440)

# clock‐time breaks on the 0–1 scale
xinx <- (c(1,6,12,18,23)*60 + 1) / 1440
xinx_lab <- c("01:00","06:00","12:00","18:00","23:00")


## ── Templates with “PC 1” etc. ─────────────────
df_plt_ind <- expand.grid(
  sind = sind,
  id   = 1:n_plt,
  high = c("low","high"),
  PC   = paste0("PC ", 1:K),
  stringsAsFactors = FALSE
) %>% 
  mutate(high = factor(high, levels = c("low","high")))

df_plt_ind_mu <- expand.grid(
  sind  = sind,
  high  = c("low","high"),
  PC    = paste0("PC ", 1:K),
  value = NA,
  stringsAsFactors = FALSE
) %>% 
  mutate(high = factor(high, levels = c("low","high")))


## ── Loop on the FPCA‐fitted curves Yhat ─────────────────────────


mu_vec <- c()
ind_vec <- c()

for(k in 1:K) {
  # 3a) 10th / 90th score cutoffs
  sc <- fpca_MIMS_subj$scores[,k]
  q <- quantile(sc, c(0.1, 0.9))
  lo <- which(sc <= q[1])
  hi <- which(sc >  q[2])
  
  # 3b) group means from *Yhat*
  mu_lo <- colMeans(fpca_MIMS_subj$Yhat[lo,  ])
  mu_hi <- colMeans(fpca_MIMS_subj$Yhat[hi,  ])
  mu_vec <- c(mu_vec, mu_lo, mu_hi)
  
  # 3c) sample n_plt curves from Yhat
  sam_lo <- sample(lo, size = n_plt)
  sam_hi <- sample(hi, size = n_plt)
  ind_lo <- as.vector(t(fpca_MIMS_subj$Yhat[sam_lo, ]))
  ind_hi <- as.vector(t(fpca_MIMS_subj$Yhat[sam_hi, ]))
  ind_vec <- c(ind_vec, ind_lo, ind_hi)
}

df_plt_ind_mu$value <- mu_vec
df_plt_ind$value <- ind_vec



# ── Turn into tfd object ─────────────

xinx <- (c(1, 6, 12, 18, 23) * 60 + 1) / 1440
xinx_lab <- c("01:00","06:00","12:00","18:00","23:00")

#  individuals -> one row per (PC, high, id)
ind_tf <- df_plt_ind %>%
  group_by(PC, high, id) %>%
  summarize(curve = tfd(value, arg = sind), .groups = "drop")

#  means -> one row per (PC, high)
mu_tf <- df_plt_ind_mu %>%
  group_by(PC, high) %>%
  summarize(curve = tfd(value, arg = sind), .groups = "drop")

# ─────────────────── Plot ─────────────
#Goal:
#We can then plot the average and individual curves. We do see the individual curves
#which load highly on each of the first four PCs do, on average, largely reflect the shapes of the PCs, with this visual effect most strong for the first three PCs.

ggplot() +
  # thin & transparent individual curves
  geom_spaghetti(
    data      = ind_tf,
    aes(y = curve, color = high),  # Use 'y' instead of 'tf'
    linewidth = 0.5,
    alpha     = 0.4
  ) +
  # thick & opaque mean curves
  geom_spaghetti(
    data      = mu_tf,
    aes(y = curve, color = high),  # Use 'y' instead of 'tf'
    linewidth = 2
  ) +
  facet_wrap(~ PC, ncol = 2, scales = "free_y") +
  scale_x_continuous(
    breaks = xinx,
    labels = xinx_lab,
    expand = c(0, 0)
  )+
  labs(
    x     = "Time of Day",
    y     = expression("MIMS: " * W[i](s)),
    color = "Group"
  ) +
  scale_color_manual(
    values = c(low = "steelblue", high = "tomato"),
    labels = c("Bottom 10%", "Top 10%")
  ) +
  theme_minimal(base_size = 16) +
  theme(
    panel.spacing    = unit(0.8, "cm"),
    panel.grid       = element_blank(),
    axis.line        = element_line(linewidth = 1),
    axis.ticks       = element_line(linewidth = 1),
    strip.text       = element_text(face = "bold", size = 16, hjust = 0),
    legend.position  = "bottom",
    legend.background = element_blank()
  )

```


