---
title: "chapter 3"
author: "Vanilton Paulo"
date: "2025-08-16"
output:
  html_document: default
editor_options: 
  markdown: 
    wrap: 72
---

# Functional Principal Components Analysis

The National Health and Nutrition Examination Survey (NHANES) is the
only national survey in the U.S. that combines health interviews,
dietary assessments, physical exams, and laboratory tests for
participants of all ages.

In this case study, NHANES 2011-2014 physical activity data is used ,
filtering for participants aged 5 to 80 who had at least one day of
accelerometry data, resulting in 11,820 participants.

The primary concern of this chapter is FPCA methods differences in their approaches
to eigenfunctions and scores estimation. 

```{r setup, echo = TRUE, message = FALSE}
# ─Packages───────────────────
# List of required packages
packages <- c(
  "refund",
  "tidyverse",
  "tidyfun",
  "patchwork",
  "here"
)

# Install missing packages
install_if_missing <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

# Install missing packages
invisible(lapply(packages, install_if_missing))



# Load packages
library(refund)      
library(tidyverse)   
library(tidyfun)
library(patchwork)
library(here)

# For reproducible results
set.seed(53615)
```

```{r load-data, include = TRUE}
# ─── Load data  ───────────────────
df_subj <- read_rds(here("data", "nhanes_fda_with_r.rds"))
```

```{r data-transformation, include = TRUE, fig.width = 9}
# ─── Data Preparation ───────────────────
# Filter out participants 80+ and younger than 5
df_subj <- df_subj %>% filter(age >= 5, age < 80)
MIMS_mat <- unclass(df_subj$MIMS) 
```

```{r fpca-face, echo = TRUE, results = 'hide', fig.width = 9}
# ─── fpca.face ───────────────────
# Do fPCA on the subject-average MIMS profiles
fpca_MIMS_subj <- fpca.face(MIMS_mat)
fpc_face <- tfd(t(fpca_MIMS_subj$efunctions[, 1:4]), arg = 1:1440)
# FACE does not re-scale eigenvectors correctly
# FACE scaling depends on no. of gridpoints not length of domain,
tf_integrate(fpc_face^2)
#[1] 0.9999874 0.9989462 0.9988505 0.9992566

fpca_face_tf <- fpc_face %>%
  set_names(paste0("PC", 1:4))
# tfd[4] on (1,1440) based on 1440 evaluations each
# interpolation by tf_approx_linear 
# PC1: (1,-0.004);(2,-0.004);(3,-0.004); ...
# PC2: (1,  0.03);(2,  0.03);(3,  0.03); ...
# PC3: (1,  0.03);(2,  0.03);(3,  0.03); ...
# PC4: (1,  0.03);(2,  0.03);(3,  0.03); ...
```

```{r fpca-2s, echo = TRUE, results = 'hide', fig.width = 9}
# ─── fpca2s ───────────────────
argvals <- seq(0, 1, length.out = ncol(MIMS_mat))
fpca2s_obj <- fpca2s(Y = MIMS_mat, npc = 4, argvals = argvals)
fpc_2s <- tfd(t(fpca2s_obj$efunctions[, 1:4]), arg = seq(1, 1440))
# 2s does not re-scale eigenvectors correctly
# 2s ignores domain length
tf_integrate(fpc_2s^2)
#[1] 1438.940 1437.387 1436.987 1437.529

fpca2s_tf <- fpc_2s %>%
  set_names(paste0("PC", 1:4))
# tfd[4] on (1,1440) based on 1440 evaluations each
# interpolation by tf_approx_linear 
# PC1: (1,0.1);(2,0.1);(3,0.1); ...
# PC2: (1, -1);(2, -1);(3, -1); ...
# PC3: (1,  1);(2,  1);(3,  1); ...
# PC4: (1, -1);(2, -1);(3, -1); ...
```

```{r fpca-basis, echo = TRUE, results = 'hide', fig.width = 9}
# ─── tfb_fpc ───────────────────
tfb_fpc_obj <- tfb_fpc(MIMS_mat)  # default is SVD-based + spline smoothing
basis_functions <- tf_basis(tfb_fpc_obj, as_tfd = TRUE)
# skip the mean (first function), extract PC1 to PC4
fpc_tf <- basis_functions[2:5]
tf_integrate(fpc_tf^2) #orthonormal functions!
#[1] 1 1 1 1


tfb_tf <- -fpc_tf %>%
  set_names(paste0("PC", 1:4))  
# tfd[4] on (1,1440) based on 1440 evaluations each
# interpolation by tf_approx_linear 
# PC1: (1,-0.004);(2,-0.004);(3,-0.004); ...
# PC2: (1, -0.03);(2, -0.03);(3, -0.03); ...
# PC3: (1,  0.03);(2,  0.03);(3,  0.03); ...
# PC4: (1,  0.03);(2,  0.03);(3,  0.03); ...
```

```{r plot, include = TRUE, fig.width = 25, fig.height = 9}
# ─── Common plot bits ─────────────
time_breaks <- c(1, 6 * 60, 12 * 60, 18 * 60, 23 * 60)
time_labels <- c("01:00", "06:00", "12:00", "18:00", "23:00")

make_pc_plot <- function(dat, title_txt) {
  ggplot(dat, aes(y = curve, color = Component)) +
    geom_spaghetti(alpha = 2) +   # one line per tf curve (PC) 
    scale_x_continuous(breaks = time_breaks, labels = time_labels, expand = c(0, 0)) +
    labs(
      title = title_txt,
      x = "Time of Day (s)",
      y = expression("Estimated Eigenfunctions (" * phi[k](s) * ")"),
      color = "Eigenfunction"
    ) +
    theme_minimal(base_size = 18) +
    theme(
      panel.grid      = element_blank(),
      axis.line       = element_line(linewidth = 1),
      axis.ticks      = element_line(linewidth = 1),
      plot.title      = element_text(face = "bold", size = 18, hjust = 0),
      legend.position.inside = c(0.9, 0.9),
      legend.background = element_blank()
    ) +
    guides(color = guide_legend(ncol = 2))
}

# ─── Build data frames per method ─
df_face <- tibble(Component = names(fpca_face_tf), curve = fpca_face_tf)
df_fpca2s <- tibble(Component = names(fpca2s_tf),    curve = fpca2s_tf)
df_tfb <- tibble(Component = names(tfb_tf),       curve = tfb_tf)

# ─── Three individual plots ───────
p_face <- make_pc_plot(df_face, "(A) fPCA (face)")
p_fpca2s <- make_pc_plot(df_fpca2s, "(B) fPCA (fpca2s)")
p_tfb <- make_pc_plot(df_tfb,  "(C) fPCA (tfb_fpc)")


p_face + p_fpca2s + p_tfb
```

First four eigenfunctions estimated using three FPCA approaches applied
to the NHANES data: (A) FPCA with fast covariance estimation
(`fpca.face`, left panel), (B) FPCA by SSVD method (`fpca2s`, center
panel), and (C) `tfb_fpc` (right panel). The principal components are
color-coded as follows: PC1 (red), PC2 (green), PC3 (blue), and PC4
(magenta).

Despite some differences, the broad shapes of the eigenfunctions are consistent
across approaches. This is good since they are aiming to solve the same problem.




Here, we plot the individuals in the bottom and top 10% of scores for the first four PCs. 
```{r interpretation, include = TRUE, fig.width = 9}
#─────────────────────────── Goal ──────────────────────────────────────────────────────
#Interpreting the functional PCs may be challenging, particularly for PCs which explain a relatively 
#low proportion of variance. One visualization technique is to plot the distribution of curves which 
#load lowest/highest on a particular PC. 

#Task: Here, we plot the individuals in the bottom and top 10% of scores for the first four PCs. 


set.seed(1983)
# number of eigenfunctions to plot
K <- 4
# number of sample curves to plot for each PC
n_plt <- 10
sind  <- seq(0, 1, length.out = 1440)

# clock‐time breaks on the 0–1 scale
xinx <- (c(1,6,12,18,23)*60 + 1) / 1440
xinx_lab <- c("01:00","06:00","12:00","18:00","23:00")


## ── Templates with PC 1 etc. ─────────────────
df_plt_ind <- expand.grid(
  sind = sind,
  id   = 1:n_plt,
  high = c("low","high"),
  PC = paste0("PC ", 1:K),
  stringsAsFactors = FALSE
) %>% 
  mutate(high = factor(high, levels = c("low","high")))

df_plt_ind_mu <- expand.grid(
  sind  = sind,
  high = c("low","high"),
  PC = paste0("PC ", 1:K),
  value = NA,
  stringsAsFactors = FALSE
) %>% 
  mutate(high = factor(high, levels = c("low","high")))


## ── Loop on the FPCA‐fitted curves Yhat ─────────────────────────


mu_vec <- c()
ind_vec <- c()

for(k in 1:K) {
  #  10th / 90th score cutoffs
  sc <- fpca_MIMS_subj$scores[,k]
  q <- quantile(sc, c(0.1, 0.9))
  lo <- which(sc <= q[1])
  hi <- which(sc >  q[2])
  
  # group means from Yhat
  mu_lo <- colMeans(fpca_MIMS_subj$Yhat[lo,  ])
  mu_hi <- colMeans(fpca_MIMS_subj$Yhat[hi,  ])
  mu_vec <- c(mu_vec, mu_lo, mu_hi)
  
  #  sample n_plt curves from Yhat
  sam_lo <- sample(lo, size = n_plt)
  sam_hi <- sample(hi, size = n_plt)
  ind_lo <- as.vector(t(fpca_MIMS_subj$Yhat[sam_lo, ]))
  ind_hi <- as.vector(t(fpca_MIMS_subj$Yhat[sam_hi, ]))
  ind_vec <- c(ind_vec, ind_lo, ind_hi)
}

df_plt_ind_mu$value <- mu_vec
df_plt_ind$value <- ind_vec



# ── Turn into tfd object ─────────────

xinx <- (c(1, 6, 12, 18, 23) * 60 + 1) / 1440
xinx_lab <- c("01:00","06:00","12:00","18:00","23:00")

#  individuals -> one row per (PC, high, id)
ind_tf <- df_plt_ind %>%
  group_by(PC, high, id) %>%
  summarize(curve = tfd(value, arg = sind), .groups = "drop")

#  means -> one row per (PC, high)
mu_tf <- df_plt_ind_mu %>%
  group_by(PC, high) %>%
  summarize(curve = tfd(value, arg = sind), .groups = "drop")

# ─────────────────── Plot ─────────────
#Goal:
# We can then plot the average and individual curves. We do see the individual curves
# which load highly on each of the first four PCs do, on average, largely reflect the shapes of the PCs, with this visual effect  strongest for the first three PCs.

ggplot() +
  geom_spaghetti(
    data = ind_tf,
    aes(y = curve, color = high),  
    linewidth = 0.5,
    alpha = 0.4
  ) +
  geom_spaghetti(
    data = mu_tf,
    aes(y = curve, color = high),  
    linewidth = 2
  ) +
  facet_wrap(~ PC, ncol = 2, scales = "free_y") +
  scale_x_continuous(
    breaks = xinx,
    labels = xinx_lab,
    expand = c(0, 0)
  )+
  labs(
    x  = "Time of Day",
    y = expression("MIMS: " * W[i](s)),
    color = "Group"
  ) +
  scale_color_manual(
    values = c(low = "steelblue", high = "tomato"),
    labels = c("Bottom 10%", "Top 10%")
  ) +
  theme_minimal(base_size = 16) +
  theme(
    panel.spacing = unit(0.8, "cm"),
    panel.grid = element_blank(),
    axis.line  = element_line(linewidth = 1),
    axis.ticks = element_line(linewidth = 1),
    strip.text = element_text(face = "bold", size = 16, hjust = 0),
    legend.position = "bottom",
    legend.background = element_blank()
  )

```

Physical activity trajectory of 10 individuals in the top 10 percent of
scores (thin red line) and their average physical activity trajectory
(thick red line).Physical activity trajectory of 10 individuals in the
lowest 10 percent of scores (thin blue line) and their average physical
activity trajectory (thick blue line).

The top-left panel displays trajectories of 10 individuals in the top 10
percent of PC1 scores (thin red lines) and their average (thick red
line), compared with 10 individuals in the bottom 10 percent of PC1
scores (thin blue lines) and their average (thick blue line). The top 10
percent group is much more active during the day, while the bottom 10
percent have lower daytime activity and, in some cases are more active
at night, specifically past 11 pm. The remaining panels show similar
contrasts for PC2–PC4. As expected, differences become less pronounced
for higher-order PCs, since they explain less variability
